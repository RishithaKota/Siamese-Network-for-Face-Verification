# -*- coding: utf-8 -*-
"""evaluate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ld7BImbN2mQ7JM4LS89OFgvzyoAgZmLd
"""

import os
import cv2
import random
import numpy as np
import tensorflow as tf
import keras
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc

!file /content/faces.zip

!unzip /content/faces.zip -d /content/data

DATASET_DIR = "/content/data/Face Data/Face Dataset"

DATASET_DIR = "/content/data/Face Data/Face Dataset"

MODEL_PATH = "siamese_model.keras"
DATASET_DIR = "/content/data/Face Data/Face Dataset"
IMG_SIZE = 128
MAX_PAIRS = 1000

def build_embedding_no_lambda():
    model = tf.keras.Sequential([
        tf.keras.layers.Input((IMG_SIZE, IMG_SIZE, 3)),
        tf.keras.layers.Conv2D(32, 3, activation="relu"),
        tf.keras.layers.MaxPooling2D(),
        tf.keras.layers.Conv2D(64, 3, activation="relu"),
        tf.keras.layers.MaxPooling2D(),
        tf.keras.layers.Conv2D(128, 3, activation="relu"),
        tf.keras.layers.GlobalAveragePooling2D(),
        tf.keras.layers.Dense(128)
    ])
    return model

print("[INFO] Rebuilding embedding model without Lambda...")
embedding_model = build_embedding_no_lambda()

print("[INFO] Loading trained weights...")
trained_model = tf.keras.models.load_model(
    MODEL_PATH,
    compile=False
)

embedding_model.set_weights(trained_model.get_weights())
print("[INFO] Weights loaded successfully")

def preprocess_image(path):
    img = cv2.imread(path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))
    return img / 255.0

def create_verification_pairs(dataset_dir, max_pairs):
    pairs, labels = [], []

    ids = [
        pid for pid in os.listdir(dataset_dir)
        if os.path.isdir(os.path.join(dataset_dir, pid))
        and len(os.listdir(os.path.join(dataset_dir, pid))) >= 2
    ]

    random.shuffle(ids)

    for pid in ids[: max_pairs // 2]:
        imgs = os.listdir(os.path.join(dataset_dir, pid))

        img1, img2 = random.sample(imgs, 2)
        pairs.append((pid, img1, pid, img2))
        labels.append(1)


        neg_pid = random.choice([x for x in ids if x != pid])
        neg_img = random.choice(os.listdir(os.path.join(dataset_dir, neg_pid)))
        pairs.append((pid, img1, neg_pid, neg_img))
        labels.append(0)

    return pairs, np.array(labels)

print("[INFO] Creating verification pairs...")
pairs, labels = create_verification_pairs(DATASET_DIR, MAX_PAIRS)

print("[INFO] Computing embeddings and distances...")
distances = []

for p1, i1, p2, i2 in pairs:
    img1 = preprocess_image(os.path.join(DATASET_DIR, p1, i1))
    img2 = preprocess_image(os.path.join(DATASET_DIR, p2, i2))

    e1 = embedding_model.predict(img1[None, ...], verbose=0)
    e2 = embedding_model.predict(img2[None, ...], verbose=0)

    e1 = e1 / np.linalg.norm(e1, axis=1, keepdims=True)
    e2 = e2 / np.linalg.norm(e2, axis=1, keepdims=True)

    dist = np.linalg.norm(e1 - e2)
    distances.append(dist)

distances = np.array(distances)

print("[INFO] Generating ROC curve...")
fpr, tpr, _ = roc_curve(labels, distances)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(6, 6))
plt.plot(fpr, tpr, label=f"AUC = {roc_auc:.3f}")
plt.plot([0, 1], [0, 1], "--")
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve â€“ Face Verification")
plt.legend()
plt.grid(True)
plt.savefig("roc_curve.png")
plt.show()

print(f"[INFO] ROC AUC: {roc_auc:.3f}")
print("[INFO] roc_curve.png saved successfully")